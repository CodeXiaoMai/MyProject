<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="code_handler">
                    "\n" 
            "package com.xiaomai.myproject.handler;\n" 
            "\n" 
            "import android.os.Handler;\n" 
            "import android.os.Message;\n" 
            "\n" 
            "import com.xiaomai.myproject.R;\n" 
            "import com.xiaomai.myproject.base.BaseActivity;\n" 
            "import com.xiaomai.myproject.view.MyToast;\n" 
            "\n" 
            "import java.lang.ref.WeakReference;\n" 
            "\n" 
            "/**\n" 
            " * Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR\n" 
            " * 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler\n" 
            " * 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一\n" 
            " * Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。\n" 
            " * 由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity\n" 
            " * 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。\n" 
            " */\n" 
            "public class HandlerActivity extends BaseActivity {\n" 
            "\n" 
            "    private final MyHandler mHandler = new MyHandler(this);\n" 
            "\n" 
            "    /**\n" 
            "     * 当匿名类是静态的时候，不会持有外部类的引用\n" 
            "     */\n" 
            "    private static final Runnable sRunnable = new Runnable() {\n" 
            "        @Override\n" 
            "        public void run() {\n" 
            "\n" 
            "        }\n" 
            "    };\n" 
            "\n" 
            "    @Override\n" 
            "    protected int getContentLayout() {\n" 
            "        return R.layout.activity_handler;\n" 
            "    }\n" 
            "\n" 
            "    @Override\n" 
            "    protected void initViews() {\n" 
            "        super.initViews();\n" 
            "        setTitle(\"Handler避免内存泄漏\");\n" 
            "    }\n" 
            "\n" 
            "    @Override\n" 
            "    protected void loadData() {\n" 
            "        super.loadData();\n" 
            "        mHandler.postDelayed(sRunnable, 1000 * 60 * 10);\n" 
            "        MyToast.show(this, \"finish\");\n" 
            "//        finish();\n" 
            "    }\n" 
            "\n" 
            "    /**\n" 
            "     * 静态内部类的实例不会持有外部类的引用\n" 
            "     */\n" 
            "    private static class MyHandler extends Handler {\n" 
            "\n" 
            "        /**\n" 
            "         * 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。\n" 
            "         * 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。\n" 
            "         */\n" 
            "        private final WeakReference&lt;HandlerActivity&gt; mActivity;\n"
            "\n" 
            "        public MyHandler(HandlerActivity activity) {\n" 
            "            mActivity = new WeakReference&lt;&gt;(activity);\n" 
            "        }\n" 
            "\n" 
            "        @Override\n" 
            "        public void handleMessage(Message msg) {\n" 
            "            HandlerActivity activity = mActivity.get();\n" 
            "            if (activity != null) {\n" 
            "                super.handleMessage(msg);\n" 
            "            }\n" 
            "        }\n" 
            "    }\n" 
            "\n" 
            "    /**\n" 
            "     * Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列\n" 
            "     * MessageQueue 中的消息。\n" 
            "     */\n" 
            "    @Override\n" 
            "    protected void onDestroy() {\n" 
            "        super.onDestroy();\n" 
            "        mHandler.removeCallbacksAndMessages(this);\n" 
            "    }\n" 
            "}\n"
    </string>
</resources>