<?xml version="1.0" encoding="utf-8"?>
<resources>
    
    <string name="code_rx_java_simple">
        "\n"
            "package com.xiaomai.myproject.rxjava;\n"
            "\n"
            "import android.widget.TextView;\n"
            "\n"
            "import com.xiaomai.myproject.R;\n"
            "import com.xiaomai.myproject.base.BaseActivity;\n"
            "import com.xiaomai.myproject.view.MyToast;\n"
            "\n"
            "import java.util.ArrayList;\n"
            "import java.util.List;\n"
            "import java.util.Random;\n"
            "\n"
            "import rx.Observable;\n"
            "import rx.Observer;\n"
            "import rx.Subscriber;\n"
            "\n"
            "public class RxJavaSimpleActivity extends BaseActivity {\n"
            "\n"
            "    private TextView tv_rx_java_simple;\n"
            "\n"
            "    @Override\n"
            "    protected int getContentLayout() {\n"
            "        return R.layout.activity_rx_java_simple;\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    protected void initViews() {\n"
            "        super.initViews();\n"
            "        setTitle(\"RxJava的简单使用\");\n"
            "        tv_rx_java_simple = (TextView) findViewById(R.id.tv_rx_java_simple);\n"
            "\n"
            "        /**\n"
            "         * 1) 创建 Observer&lt;br&gt;\n"
    "         * Observer 即观察者，它决定事件触发的时候将有怎样的行为。\n"
    "         */\n"
    "        final Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n"
    "\n"
    "            @Override\n"
    "            public void onCompleted() {\n"
    "                MyToast.show(mContext, \"onCompleted\");\n"
    "            }\n"
    "\n"
    "            @Override\n"
    "            public void onError(Throwable e) {\n"
    "                tv_rx_java_simple.setText(\"onError:\" + e.getMessage());\n"
    "            }\n"
    "\n"
    "            @Override\n"
    "            public void onNext(String s) {\n"
    "                tv_rx_java_simple.setText(s);\n"
    "            }\n"
    "        };\n"
    "\n"
    "        /**\n"
    "         * 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。\n"
    "         * Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的，\n"
    "         * 不仅基本使用方式一样，实质上，在RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个\n"
    "         * Subscriber再使用。 所以如果你只想使用基本功能，选择 Observer 和 Subscriber\n"
    "         * 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在\n"
    "         * subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，\n"
    "         * 默认情况下它的实现为空。需要注意的是， 如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行），onStart()\n"
    "         * 就不适用了， 因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用\n"
    "         * doOnSubscribe() 方法。 unsubscribe(): 这是 Subscriber 所实现的另一个接口\n"
    "         * Subscription的方法，用于取消订阅。 在这个方法被调用后，Subscriber\n"
    "         * 将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed() 先判断一下状态。 unsubscribe()\n"
    "         * 这个方法很重要，因为在 subscribe() 之后，Observable 会持有 Subscriber\n"
    "         * 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则： 要在不再使用的时候尽快在合适的地方（例如\n"
    "         * onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。\n"
    "         */\n"
    "        Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {\n"
    "\n"
    "            @Override\n"
    "            public void onStart() {\n"
    "                super.onStart();\n"
    "            }\n"
    "\n"
    "            @Override\n"
    "            public void onCompleted() {\n"
    "\n"
    "            }\n"
    "\n"
    "            @Override\n"
    "            public void onError(Throwable e) {\n"
    "\n"
    "            }\n"
    "\n"
    "            @Override\n"
    "            public void onNext(String s) {\n"
    "\n"
    "            }\n"
    "        };\n"
    "\n"
    "        /**\n"
    "         * 2) 创建 Observable&lt;br&gt;\n"
    "         * Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个\n"
    "         * Observable ，并为它定义事件触发规则： 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe\n"
    "         * 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe\n"
    "         * 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次\n"
    "         * onNext() 和一次\n"
    "         * onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。\n"
    "         */\n"
    "        Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n"
    "            @Override\n"
    "            public void call(Subscriber&lt;? super String> subscriber) {\n"
    "                subscriber.onStart();\n"
    "                float round = new Random().nextFloat();\n"
    "                if (round > 0.5) {\n"
    "                    subscriber.onNext(String.valueOf(round));\n"
    "                    subscriber.onCompleted();\n"
    "                } else {\n"
    "                    subscriber.onError(new Throwable(String.valueOf(round)));\n"
    "                }\n"
    "            }\n"
    "        });\n"
    "\n"
    "        /**\n"
    "         * create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，\n"
    "         */\n"
    "        /**\n"
    "         * 例如：just(T...): 将传入的参数依次发送出来。将会依次调用： onNext(\"Hello\"); onNext(\"Hi\");\n"
    "         * onNext(\"Aloha\"); onCompleted();\n"
    "         */\n"
    "        final Observable&lt;String&gt; stringObservable = Observable.just(\"Hello\", \"Hi\", \"Aloha0\");\n"
    "        /**\n"
    "         * from(T[]) 或者 from(Iterable&lt;? extends T>) : 将传入的数组或 Iterable\n"
    "         * 拆分成具体对象后，依次发送出来。\n"
    "         */\n"
    "        String[] words = {\n"
    "                \"Hello\", \"Hi\", \"Aloha1\"\n"
    "        };\n"
    "        final Observable&lt;String&gt; arrayObservable = Observable.from(words);\n"
    "        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n"
            "        list.add(\"Hello\");\n"
            "        list.add(\"Hi\");\n"
            "        list.add(\"Aloha2\");\n"
            "        final Observable&lt;String&gt; listObservable = Observable.from(list);\n"
            "\n"
            "        /**\n"
            "         * 3) Subscribe (订阅) &lt;br&gt;\n"
            "         * 创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。\n"
            "         */\n"
            "        observable.subscribe(observer);// observable.subscribe(subscriber);\n"
            "        new Thread() {\n"
            "            @Override\n"
            "            public void run() {\n"
            "                super.run();\n"
            "                try {\n"
            "                    Thread.sleep(1000);\n"
            "                    runOnUiThread(new Runnable() {\n"
            "                        @Override\n"
            "                        public void run() {\n"
            "                            stringObservable.subscribe(observer);\n"
            "                        }\n"
            "                    });\n"
            "                    Thread.sleep(1000);\n"
            "                    runOnUiThread(new Runnable() {\n"
            "                        @Override\n"
            "                        public void run() {\n"
            "                            arrayObservable.subscribe(observer);\n"
            "                        }\n"
            "                    });\n"
            "                    Thread.sleep(1000);\n"
            "                    runOnUiThread(new Runnable() {\n"
            "                        @Override\n"
            "                        public void run() {\n"
            "                            listObservable.subscribe(observer);\n"
            "\n"
            "                        }\n"
            "                    });\n"
            "                } catch (InterruptedException e) {\n"
            "                    e.printStackTrace();\n"
            "                }\n"
            "            }\n"
            "        }.start();\n"
            "    }\n"
            "}\n"
    </string>
    
    <string name="code_rx_java_complex">
                    "\n"
            "package com.xiaomai.myproject.rxjava;\n"
            "\n"
            "import android.graphics.drawable.Drawable;\n"
            "import android.view.View;\n"
            "import android.widget.Button;\n"
            "import android.widget.ImageView;\n"
            "import android.widget.TextView;\n"
            "\n"
            "import com.xiaomai.myproject.R;\n"
            "import com.xiaomai.myproject.base.BaseActivity;\n"
            "import com.xiaomai.myproject.view.MyToast;\n"
            "\n"
            "import java.util.Random;\n"
            "\n"
            "import rx.Observable;\n"
            "import rx.Observer;\n"
            "import rx.Subscriber;\n"
            "import rx.functions.Action0;\n"
            "import rx.functions.Action1;\n"
            "\n"
            "public class RxJavaComplexActivity extends BaseActivity implements View.OnClickListener {\n"
            "\n"
            "    private TextView tv_rx_java_complex;\n"
            "\n"
            "    private ImageView iv_rx_java_complex;\n"
            "\n"
            "    private Button bt_rx_java_complex_print_array;\n"
            "\n"
            "    private Button bt_rx_java_complex_get_image;\n"
            "\n"
            "    private StringBuilder mContent;\n"
            "\n"
            "    @Override\n"
            "    protected int getContentLayout() {\n"
            "        return R.layout.activity_rx_java_complex;\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    protected void initViews() {\n"
            "        super.initViews();\n"
            "        setTitle(\"RxJava的高级用法\");\n"
            "        tv_rx_java_complex = (TextView) findViewById(R.id.tv_rx_java_complex);\n"
            "        iv_rx_java_complex = (ImageView) findViewById(R.id.iv_rx_java_complex);\n"
            "        bt_rx_java_complex_print_array = (Button) findViewById(R.id.bt_rx_java_complex_print_array);\n"
            "        bt_rx_java_complex_get_image = (Button) findViewById(R.id.bt_rx_java_complex_get_image);\n"
            "        bt_rx_java_complex_get_image.setOnClickListener(this);\n"
            "        bt_rx_java_complex_print_array.setOnClickListener(this);\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    protected void initVariables() {\n"
            "        super.initVariables();\n"
            "        mContent = new StringBuilder();\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    protected void loadData() {\n"
            "        super.loadData();\n"
            "        Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n"
            "            @Override\n"
            "            public void call(Subscriber&lt;? super String> subscriber) {\n"
            "                subscriber.onStart();\n"
            "                float round = new Random().nextFloat();\n"
            "                if (round > 0.5) {\n"
            "                    subscriber.onNext(String.valueOf(round));\n"
            "                    subscriber.onCompleted();\n"
            "                } else {\n"
            "                    try {\n"
            "                        subscriber.onError(new Throwable(String.valueOf(round)));\n"
            "                    } catch (Exception e) {\n"
            "                        e.printStackTrace();\n"
            "                    }\n"
            "                }\n"
            "            }\n"
            "        });\n"
            "\n"
            "        /**\n"
            "         * 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe()\n"
            "         * 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下：\n"
            "         */\n"
            "        Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {\n"
            "            @Override\n"
            "            public void call(String s) {\n"
            "                mContent.append(\"\\nonNextAction\" + s);\n"
            "                tv_rx_java_complex.setText(mContent);\n"
            "            }\n"
            "        };\n"
            "\n"
            "        Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {\n"
            "            @Override\n"
            "            public void call(Throwable throwable) {\n"
            "                mContent.append(\"\\nonErrorAction\" + throwable.getMessage());\n"
            "                tv_rx_java_complex.setText(mContent);\n"
            "            }\n"
            "        };\n"
            "\n"
            "        Action0 onCompletedAction = new Action0() {\n"
            "            @Override\n"
            "            public void call() {\n"
            "                mContent.append(\"\\nonCompletedAction\");\n"
            "                tv_rx_java_complex.setText(mContent);\n"
            "            }\n"
            "        };\n"
            "\n"
            "        observable.subscribe(onNextAction);\n"
            "        observable.subscribe(onNextAction, onErrorAction);\n"
            "        observable.subscribe(onNextAction, onErrorAction, onCompletedAction);\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    public void onClick(View v) {\n"
            "        switch (v.getId()) {\n"
            "            case R.id.bt_rx_java_complex_print_array:\n"
            "                printArray();\n"
            "                break;\n"
            "            case R.id.bt_rx_java_complex_get_image:\n"
            "                showImage();\n"
            "                break;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    /**\n"
            "     * 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast\n"
            "     * 报错：\n"
            "     */\n"
            "    private void showImage() {\n"
            "        final int drawableRes = R.drawable.ic_launcher;\n"
            "        Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() {\n"
            "            @Override\n"
            "            public void call(Subscriber&lt;? super Drawable> subscriber) {\n"
            "                Drawable drawable = getResources().getDrawable(drawableRes);\n"
            "                subscriber.onNext(drawable);\n"
            "                subscriber.onCompleted();\n"
            "            }\n"
            "        }).subscribe(new Observer&lt;Drawable&gt;() {\n"
            "            @Override\n"
            "            public void onCompleted() {\n"
            "\n"
            "            }\n"
            "\n"
            "            @Override\n"
            "            public void onError(Throwable e) {\n"
            "                MyToast.show(mContext, e.getMessage());\n"
            "            }\n"
            "\n"
            "            @Override\n"
            "            public void onNext(Drawable drawable) {\n"
            "                iv_rx_java_complex.setImageDrawable(drawable);\n"
            "            }\n"
            "        });\n"
            "    }\n"
            "\n"
            "    /**\n"
            "     * 打印字符串数组\n"
            "     */\n"
            "    private void printArray() {\n"
            "        String[] names = {\n"
            "                \"XiaoWang\", \"XiaoLi\", \"XiaoZhang\"\n"
            "        };\n"
            "        Observable.from(names).subscribe(new Action1&lt;String&gt;() {\n"
            "            @Override\n"
            "            public void call(String s) {\n"
            "                mContent.append(\"\\n\" + s);\n"
            "                tv_rx_java_complex.setText(mContent);\n"
            "            }\n"
            "        });\n"
            "    }\n"
            "}\n"
    </string>
    
    <string name="code_rx_java_scheduler">
                    "\n"
            "package com.xiaomai.myproject.rxjava;\n"
            "\n"
            "import android.graphics.drawable.Drawable;\n"
            "import android.view.View;\n"
            "import android.widget.Button;\n"
            "import android.widget.ImageView;\n"
            "import android.widget.TextView;\n"
            "\n"
            "import com.xiaomai.myproject.R;\n"
            "import com.xiaomai.myproject.base.BaseActivity;\n"
            "\n"
            "import rx.Observable;\n"
            "import rx.Subscriber;\n"
            "import rx.android.schedulers.AndroidSchedulers;\n"
            "import rx.functions.Action1;\n"
            "import rx.schedulers.Schedulers;\n"
            "\n"
            "/**\n"
            " * 在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程生产事件；\n"
            " * 在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 &lt;br&gt;\n"
                        " * &lt;br&gt;\n"
                    " * 在RxJava 中，Scheduler ————调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。\n"
                    " * RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： &lt;br&gt;\n"
                " * Schedulers.immediate():直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 &lt;br&gt;\n"
            " * Schedulers.newThread():总是启用新线程，并在新线程执行操作。&lt;br&gt;\n"
            " * Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和 newThread()\n"
            " * 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread()\n"
            " * 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 &lt;br&gt;\n"
        " * Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被\n"
        " * I/O等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在\n"
        " * computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 &lt;br&gt;\n"
    " * 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n"
    " * 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。\n"
    " * subscribeOn(): 指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程,\n"
    " * 或者叫做事件产生的线程。 &lt;br&gt;\n"
    " * observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。\n"
    " */\n"
    "public class RxJavaSchedulerActivity extends BaseActivity implements View.OnClickListener{\n"
    "\n"
    "    private TextView tv_rx_java_scheduler;\n"
    "\n"
    "    private ImageView iv_rx_java_scheduler;\n"
    "\n"
    "    private Button bt_rx_java_scheduler_text;\n"
    "\n"
    "    private Button bt_rx_java_scheduler_image;\n"
    "\n"
    "    @Override\n"
    "    protected int getContentLayout() {\n"
    "        return R.layout.activity_rx_java_scheduler;\n"
    "    }\n"
    "\n"
    "    @Override\n"
    "    protected void initViews() {\n"
    "        super.initViews();\n"
    "        setTitle(\"RxJava的Scheduler的用法\");\n"
    "        tv_rx_java_scheduler = (TextView) findViewById(R.id.tv_rx_java_scheduler);\n"
    "        iv_rx_java_scheduler = (ImageView) findViewById(R.id.iv_rx_java_scheduler);\n"
    "        bt_rx_java_scheduler_text = (Button) findViewById(R.id.bt_rx_java_scheduler_text);\n"
    "        bt_rx_java_scheduler_image = (Button) findViewById(R.id.bt_rx_java_scheduler_image);\n"
    "        bt_rx_java_scheduler_text.setOnClickListener(this);\n"
    "        bt_rx_java_scheduler_image.setOnClickListener(this);\n"
    "\n"
    "\n"
    "\n"
    "    }\n"
    "\n"
    "    @Override\n"
    "    public void onClick(View v) {\n"
    "        switch (v.getId()) {\n"
    "            case R.id.bt_rx_java_scheduler_text:\n"
    "                showText();\n"
    "                break;\n"
    "            case R.id.bt_rx_java_scheduler_image:\n"
    "                showImage();\n"
    "                break;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    private void showImage() {\n"
    "        final int drawableRes = R.drawable.ic_launcher;\n"
    "        Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() {\n"
    "            @Override\n"
    "            public void call(Subscriber&lt;? super Drawable> subscriber) {\n"
    "                Drawable drawable = getResources().getDrawable(drawableRes);\n"
    "                subscriber.onNext(drawable);\n"
    "                subscriber.onCompleted();\n"
    "            }\n"
    "        })\n"
    "                .subscribeOn(Schedulers.io())\n"
    "                .observeOn(AndroidSchedulers.mainThread())\n"
    "                .subscribe(new Action1&lt;Drawable&gt;() {\n"
    "                    @Override\n"
    "                    public void call(Drawable drawable) {\n"
    "                        iv_rx_java_scheduler.setImageDrawable(drawable);\n"
    "                    }\n"
    "                });\n"
    "    }\n"
    "\n"
    "    private void showText() {\n"
    "        Observable.just(1, 2, 3,4)\n"
    "                .subscribeOn(Schedulers.io())   // 指定 subscribe() 发生在 IO 线程\n"
    "                .observeOn(AndroidSchedulers.mainThread())  // 指定 Subscriber 的回调发生在主线程\n"
    "                .subscribe(new Action1&lt;Integer&gt;() {\n"
    "                    @Override\n"
    "                    public void call(Integer integer) {\n"
    "                        tv_rx_java_scheduler.setText(tv_rx_java_scheduler.getText() + String.valueOf(integer));\n"
    "                    }\n"
    "                });\n"
    "    }\n"
    "}\n"
    </string>
    
    <string name="code_rx_java_flat">
                    "\n"
            "package com.xiaomai.myproject.rxjava;\n"
            "\n"
            "import android.graphics.Bitmap;\n"
            "import android.graphics.BitmapFactory;\n"
            "import android.os.Environment;\n"
            "import android.view.View;\n"
            "import android.widget.Button;\n"
            "import android.widget.ImageView;\n"
            "import android.widget.TextView;\n"
            "\n"
            "import com.xiaomai.myproject.R;\n"
            "import com.xiaomai.myproject.base.BaseActivity;\n"
            "import com.xiaomai.myproject.rxjava.bean.Course;\n"
            "import com.xiaomai.myproject.rxjava.bean.Student;\n"
            "\n"
            "import java.util.ArrayList;\n"
            "import java.util.List;\n"
            "\n"
            "import rx.Observable;\n"
            "import rx.Subscriber;\n"
            "import rx.android.schedulers.AndroidSchedulers;\n"
            "import rx.functions.Action1;\n"
            "import rx.functions.Func1;\n"
            "import rx.schedulers.Schedulers;\n"
            "\n"
            "public class RxJavaFlatActivity extends BaseActivity implements View.OnClickListener {\n"
            "\n"
            "    private Button bt_rx_java_flat_map;\n"
            "\n"
            "    private Button bt_rx_java_flat_flatMap;\n"
            "\n"
            "    private Button bt_rx_java_retrofit;\n"
            "\n"
            "    private ImageView iv_rx_java_flat;\n"
            "\n"
            "    private TextView tv_rx_java_flat;\n"
            "\n"
            "    @Override\n"
            "    protected int getContentLayout() {\n"
            "        return R.layout.activity_rx_java_flat;\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    protected void initViews() {\n"
            "        super.initViews();\n"
            "        setTitle(\"RxJava变换的使用\");\n"
            "        bt_rx_java_flat_map = (Button) findViewById(R.id.bt_rx_java_flat_map);\n"
            "        bt_rx_java_flat_flatMap = (Button) findViewById(R.id.bt_rx_java_flat_flatMap);\n"
            "        bt_rx_java_retrofit = (Button) findViewById(R.id.bt_rx_java_lift);\n"
            "        bt_rx_java_retrofit.setOnClickListener(this);\n"
            "        bt_rx_java_flat_map.setOnClickListener(this);\n"
            "        bt_rx_java_flat_flatMap.setOnClickListener(this);\n"
            "        iv_rx_java_flat = (ImageView) findViewById(R.id.iv_rx_java_flat);\n"
            "        tv_rx_java_flat = (TextView) findViewById(R.id.tv_rx_java_flat);\n"
            "    }\n"
            "\n"
            "    @Override\n"
            "    public void onClick(View v) {\n"
            "        switch (v.getId()) {\n"
            "            case R.id.bt_rx_java_flat_map:\n"
            "                map();\n"
            "                break;\n"
            "            case R.id.bt_rx_java_flat_flatMap:\n"
            "                flatMap();\n"
            "                break;\n"
            "            case R.id.bt_rx_java_lift:\n"
            "                lift();\n"
            "                break;\n"
            "        }\n"
            "    }\n"
            "\n"
            "    private void lift() {\n"
            "        Observable.just(1,2,3,4,5).lift(new Observable.Operator&lt;String, Integer&gt;() {\n"
            "            @Override\n"
            "            public Subscriber&lt;? super Integer> call(final Subscriber&lt;? super String> subscriber) {\n"
            "                return new Subscriber&lt;Integer&gt;() {\n"
            "                    @Override\n"
            "                    public void onCompleted() {\n"
            "                        subscriber.onCompleted();\n"
            "                    }\n"
            "\n"
            "                    @Override\n"
            "                    public void onError(Throwable e) {\n"
            "                        subscriber.onError(e);\n"
            "                    }\n"
            "\n"
            "                    @Override\n"
            "                    public void onNext(Integer integer) {\n"
            "                        subscriber.onNext(String.valueOf(integer));\n"
            "                    }\n"
            "                };\n"
            "            }\n"
            "        })\n"
            "        .subscribe(new Action1&lt;String&gt;() {\n"
            "            @Override\n"
            "            public void call(String s) {\n"
            "                tv_rx_java_flat.setText(tv_rx_java_flat.getText() + \"\\n\" + s);\n"
            "            }\n"
            "        });\n"
            "    }\n"
            "\n"
            "    /**\n"
            "     * flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是，\n"
            "     * flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber\n"
            "     * 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个\n"
            "     * Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个\n"
            "     * Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber\n"
            "     * 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable\n"
            "     * 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。\n"
            "     */\n"
            "    private void flatMap() {\n"
            "        List&lt;Course&gt; list1 = new ArrayList&lt;&gt;();\n"
            "        list1.add(new Course(\"数学\"));\n"
            "        list1.add(new Course(\"英语\"));\n"
            "        list1.add(new Course(\"体育\"));\n"
            "\n"
            "        List&lt;Course&gt; list2 = new ArrayList&lt;&gt;();\n"
            "        list2.add(new Course(\"自然\"));\n"
            "        list2.add(new Course(\"频道\"));\n"
            "        Student[] students = {\n"
            "                new Student(\"xiaowang\", list1), new Student(\"xiaoli\", list2)\n"
            "        };\n"
            "        Observable.from(students).flatMap(new Func1&lt;Student, Observable&lt;Course&gt;>() {\n"
            "            @Override\n"
            "            public Observable&lt;Course&gt; call(Student student) {\n"
            "                return Observable.from(student.getCourses());\n"
            "            }\n"
            "        }).subscribe(new Action1&lt;Course&gt;() {\n"
            "            @Override\n"
            "            public void call(Course course) {\n"
            "                tv_rx_java_flat.setText(tv_rx_java_flat.getText() + \"\\n\" + course.getName());\n"
            "            }\n"
            "        });\n"
            "    }\n"
            "\n"
            "    /**\n"
            "     * 这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和\n"
            "     * Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX\n"
            "     * 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 可以看到，map()\n"
            "     * 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了\n"
            "     * Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava\n"
            "     * 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。\n"
            "     */\n"
            "    private void map() {\n"
            "        Observable.just(\"/meinv1.jpg\").subscribeOn(Schedulers.io())\n"
            "                .map(new Func1&lt;String Bitmap>() {\n"
            "                    @Override\n"
            "                    public Bitmap call(String s) {\n"
            "                        String path = Environment.getExternalStorageDirectory() + s;\n"
            "                        return BitmapFactory.decodeFile(path);\n"
            "                    }\n"
            "                }).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;Bitmap&gt;() {\n"
            "                    @Override\n"
            "                    public void call(Bitmap bitmap) {\n"
            "                        iv_rx_java_flat.setImageBitmap(bitmap);\n"
            "                    }\n"
            "                });\n"
            "    }\n"
            "}\n"
    </string>
</resources>